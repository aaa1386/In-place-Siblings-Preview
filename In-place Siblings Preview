// Based on: https://github.com/euu2021/Freeplane_UtilityPanels/blob/main/utilityPanels.groovy
// Modified by aaa1386
// @ExecutionModes({ON_SINGLE_NODE="/menu_bar/aaa"})

import org.freeplane.core.ui.components.UITools
import org.freeplane.features.map.NodeModel
import org.freeplane.features.mode.Controller
import org.freeplane.plugin.script.proxy.ProxyFactory
import org.freeplane.plugin.script.proxy.ScriptUtils
import org.freeplane.view.swing.map.MapView
import org.freeplane.view.swing.map.NodeView
import org.freeplane.features.nodestyle.NodeStyleController
import org.freeplane.features.styles.LogicalStyleController.StyleOption

import javax.swing.*
import javax.swing.event.ChangeListener
import javax.swing.event.ChangeEvent
import java.awt.*
import java.awt.event.*
import java.util.ArrayList

// تنظیمات
@groovy.transform.Field boolean showSiblingsPreview = true
@groovy.transform.Field int scrollStopDelay = 1
@groovy.transform.Field ArrayList<JPanel> activeSiblingPreviewPanels = []
@groovy.transform.Field Timer scrollStopTimer = new Timer(scrollStopDelay, null)
@groovy.transform.Field boolean rightToLeftLayout = true // true=راست‌چین, false=چپ‌چین
@groovy.transform.Field boolean isScrolling = false // اضافه شده برای مدیریت وضعیت اسکرول

// شروع
initializeSiblingsPreview()

def initializeSiblingsPreview() {
    // تنظیم تایمر برای توقف اسکرول (اکنون فقط برای به روزرسانی نهایی استفاده می‌شود)
    scrollStopTimer.setRepeats(false)
    scrollStopTimer.addActionListener({
        isScrolling = false
        refreshSiblingPreviewPanels()
    })
    
    // اضافه کردن لیسنرها
    addScrollAndMoveListeners()
    
    // اولین بار اجرا
    refreshSiblingPreviewPanels()
}

def addScrollAndMoveListeners() {
    def mapView = Controller.currentController.MapViewManager.mapView
    
    // لیسنر حرکت
    mapView.addComponentListener(new ComponentAdapter() {
        public void componentMoved(ComponentEvent e) {
            if (showSiblingsPreview) {
                updatePanelPositions() // به روزرسانی موقعیت پنل‌ها
            }
        }
    })
    
    // لیسنر اسکرول
    def viewport = mapView.getParent()
    if (viewport instanceof JViewport) {
        viewport.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                if (showSiblingsPreview) {
                    if (!isScrolling) {
                        isScrolling = true
                    }
                    updatePanelPositions() // به روزرسانی موقعیت پنل‌ها در حین اسکرول
                    scrollStopTimer.restart()
                }
            }
        })
    }
}

// ★★★★ تابع جدید: به روزرسانی موقعیت پنل‌ها بدون مخفی کردن ★★★★
def updatePanelPositions() {
    if (!showSiblingsPreview || activeSiblingPreviewPanels.isEmpty()) return
    
    def mapView = Controller.currentController.MapViewManager.mapView
    def viewport = mapView.getParent()
    if (!(viewport instanceof JViewport)) return

    // فقط موقعیت پنل‌های موجود را به روز کن (بدون ایجاد پنل جدید)
    activeSiblingPreviewPanels.each { panel ->
        def nodeData = panel.getClientProperty("nodeData")
        if (nodeData != null) {
            def nodeNotProxy = nodeData.node
            def positionAtBottom = nodeData.positionAtBottom
            
            NodeView nodeView = mapView.getNodeView(nodeNotProxy)
            if (nodeView != null) {
                Point nodePoint = mapView.getNodeContentLocation(nodeView)
                Point nodeScreen = SwingUtilities.convertPoint(mapView, nodePoint, viewport)
                
                // محاسبه موقعیت جدید
                int referenceNodeScreenX = nodeScreen.x
                int referenceNodeScreenY = nodeScreen.y
                
                // ★★★★ محاسبه عرض هوشمند ★★★★
                int smartPanelWidth = calculateSmartWidthWithHierarchy(nodeNotProxy, referenceNodeScreenX, mapView, viewport)
                
                // موقعیت گره مرجع برای محاسبه نقطه شروع
                int nodeLeftEdge = nodeScreen.x
                int nodeRightEdge = nodeScreen.x + nodeView.getContentPane().width
                
                // ★★★★ محاسبه نقطه شروع بر اساس چیدمان ★★★★
                int panelStartX
                if (rightToLeftLayout) {
                    // راست‌چین: شروع از سمت راست گره مرجع
                    panelStartX = nodeRightEdge - smartPanelWidth
                } else {
                    // چپ‌چین: شروع از سمت چپ گره مرجع  
                    panelStartX = nodeLeftEdge
                }
                
                // تنظیم موقعیت جدید
                if (!positionAtBottom) {
                    panel.setLocation(panelStartX, referenceNodeScreenY - panel.getHeight())
                } else {
                    panel.setLocation(panelStartX, referenceNodeScreenY + nodeView.getContentPane().height)
                }
                
                // تنظیم اندازه اگر لازم است
                if (panel.getWidth() != smartPanelWidth) {
                    panel.setSize(smartPanelWidth, panel.getHeight())
                    def scrollPane = panel.getComponent(0) // فرض می‌کنیم اولین کامپوننت JScrollPane است
                    if (scrollPane instanceof JScrollPane) {
                        scrollPane.setPreferredSize(new Dimension(smartPanelWidth, panel.getHeight()))
                        scrollPane.revalidate()
                    }
                }
            }
        }
    }
    
    // فورس رندر کردن
    mapView.repaint()
}

def refreshSiblingPreviewPanels() {
    // پاک کردن پنل‌های قبلی
    activeSiblingPreviewPanels.each { panel ->
        panel.setVisible(false)
        panel.getParent()?.remove(panel)
    }
    activeSiblingPreviewPanels.clear()

    if (!showSiblingsPreview) return

    def mapView = Controller.currentController.MapViewManager.mapView
    def viewport = mapView.getParent()
    if (!(viewport instanceof JViewport)) return

    def c = ScriptUtils.c()
    
    // پردازش همه نودها
    c.viewRoot.findAll().each { nodeProxy ->
        if (nodeProxy == c.viewRoot) return

        def testedNode = nodeProxy.delegate
        if (testedNode == null) return

        NodeView testedNodeView = mapView.getNodeView(testedNode)
        if (testedNodeView == null) return
        
        Point selectedPointOnMap = mapView.getNodeContentLocation(testedNodeView)
        Point selectedPointOnScreen = SwingUtilities.convertPoint(mapView, selectedPointOnMap, viewport)

        // فقط اگر نود والد داشته باشد و siblings بیشتر از 1
        if (testedNode.parent?.children?.size() == 1) return

        def parentNode = testedNode.parent
        def siblings = parentNode.children
        int selectedIndex = siblings.indexOf(testedNode)
        if (selectedIndex < 0) return

        // بررسی siblingهای بالا
        NodeModel offScreenSiblingAbove = null
        if (selectedIndex > 0 && !isNodeVisibleInViewport(siblings[selectedIndex - 1])) {
            offScreenSiblingAbove = siblings[selectedIndex - 1]
        }

        if (offScreenSiblingAbove != null) {
            NodeView offScreenSiblingAboveNodeView = mapView.getNodeView(offScreenSiblingAbove)
            Point offScreenSiblingAboveSelectedPointOnMap = mapView.getNodeContentLocation(offScreenSiblingAboveNodeView)
            Point offScreenSiblingAboveSelectedPointOnScreen = SwingUtilities.convertPoint(mapView, offScreenSiblingAboveSelectedPointOnMap, viewport)
            
            if (selectedPointOnScreen.y >= 0 && offScreenSiblingAboveSelectedPointOnScreen.y <= 0 && 
                selectedPointOnScreen.x > 0 && selectedPointOnScreen.x < viewport.getWidth()) {
                
                def siblingsPreviewPanelCreated = createSiblingPreviewPanel(testedNode, false, selectedPointOnScreen.x as int, selectedPointOnScreen.y as int)
                if (siblingsPreviewPanelCreated) {
                    activeSiblingPreviewPanels.add(siblingsPreviewPanelCreated)
                }
            }
        }

        // بررسی siblingهای پایین
        NodeModel offScreenSiblingBelow = null
        if (selectedIndex + 1 < siblings.size() && !isNodeVisibleInViewport(siblings[selectedIndex + 1])) {
            offScreenSiblingBelow = siblings[selectedIndex + 1]
        }

        if (offScreenSiblingBelow != null) {
            NodeView offScreenSiblingBelowNodeView = mapView.getNodeView(offScreenSiblingBelow)
            Point offScreenSiblingBelowSelectedPointOnMap = mapView.getNodeContentLocation(offScreenSiblingBelowNodeView)
            Point offScreenSiblingBelowSelectedPointOnScreen = SwingUtilities.convertPoint(mapView, offScreenSiblingBelowSelectedPointOnMap, viewport)
            
            if (selectedPointOnScreen.y < viewport.getHeight() && 
                offScreenSiblingBelowSelectedPointOnScreen.y >= viewport.getHeight() && 
                selectedPointOnScreen.x > 0 && selectedPointOnScreen.x < viewport.getWidth()) {
                
                def siblingsPreviewPanelCreated = createSiblingPreviewPanel(testedNode, true, selectedPointOnScreen.x as int, selectedPointOnScreen.y as int)
                if (siblingsPreviewPanelCreated) {
                    activeSiblingPreviewPanels.add(siblingsPreviewPanelCreated)
                }
            }
        }
    }
    
    // بروزرسانی نمایش
    mapView.repaint()
}

// ★★★★ تابع کمکی: پیدا کردن نزدیک‌ترین مانع سمت چپ (برای راست‌چین) ★★★★
def int findClosestLeftObstacle(NodeModel referenceNode, int referenceRightEdge, MapView mapView, JViewport viewport) {
    int closestObstacle = 0 // ابتدای viewport
    
    c.viewRoot.findAll().each { nodeProxy ->
        NodeModel otherNode = nodeProxy.delegate
        if (otherNode != referenceNode) {
            NodeView otherNodeView = mapView.getNodeView(otherNode)
            if (otherNodeView != null && isNodeVisibleInViewport(otherNode)) {
                Point otherPoint = mapView.getNodeContentLocation(otherNodeView)
                Point otherScreen = SwingUtilities.convertPoint(mapView, otherPoint, viewport)
                int otherRightEdge = otherScreen.x + otherNodeView.getContentPane().width
                
                // اگر گره در سمت چپ گره مرجع است و لبه راست آن نزدیک‌تر از مانع فعلی است
                if (otherRightEdge < referenceRightEdge && otherRightEdge > closestObstacle) {
                    closestObstacle = otherRightEdge
                }
            }
        }
    }
    
    return closestObstacle
}

// ★★★★ تابع کمکی: پیدا کردن نزدیک‌ترین مانع سمت راست (برای چپ‌چین) ★★★★
def int findClosestRightObstacle(NodeModel referenceNode, int referenceLeftEdge, MapView mapView, JViewport viewport) {
    int closestObstacle = viewport.getWidth() // انتهای viewport
    
    c.viewRoot.findAll().each { nodeProxy ->
        NodeModel otherNode = nodeProxy.delegate
        if (otherNode != referenceNode) {
            NodeView otherNodeView = mapView.getNodeView(otherNode)
            if (otherNodeView != null && isNodeVisibleInViewport(otherNode)) {
                Point otherPoint = mapView.getNodeContentLocation(otherNodeView)
                Point otherScreen = SwingUtilities.convertPoint(mapView, otherPoint, viewport)
                int otherLeftEdge = otherScreen.x
                
                // اگر گره در سمت راست گره مرجع است و لبه چپ آن نزدیک‌تر از مانع فعلی است
                if (otherLeftEdge > referenceLeftEdge && otherLeftEdge < closestObstacle) {
                    closestObstacle = otherLeftEdge
                }
            }
        }
    }
    
    return closestObstacle
}

// ★★★★ تابع جدید: محاسبه عرض هوشمند بر اساس چیدمان ★★★★
def int calculateSmartWidthWithHierarchy(NodeModel nodeNotProxy, int referenceNodeScreenX, MapView mapView, JViewport viewport) {
    NodeView nodeView = mapView.getNodeView(nodeNotProxy)
    if (nodeView == null) return 300
    
    // موقعیت گره مرجع
    Point nodePoint = mapView.getNodeContentLocation(nodeView)
    Point nodeScreen = SwingUtilities.convertPoint(mapView, nodePoint, viewport)
    int nodeLeftEdge = nodeScreen.x
    int nodeRightEdge = nodeScreen.x + nodeView.getContentPane().width
    
    if (rightToLeftLayout) {
        // ★ راست‌چین: شروع از سمت راست گره مرجع به سمت چپ ★
        
        // 1. نقطه شروع: سمت راست گره مرجع
        int startPoint = nodeRightEdge
        
        // 2. پیدا کردن موانع در سمت چپ (از راست به چپ)
        int closestObstacle = findClosestLeftObstacle(nodeNotProxy, nodeRightEdge, mapView, viewport)
        
        // 3. عرض نهایی: از سمت راست گره مرجع تا نزدیک‌ترین مانع سمت چپ
        int availableWidth = startPoint - closestObstacle - 10 // فاصله 10 پیکسل
        
        return Math.max(150, Math.min(400, availableWidth))
        
    } else {
        // ★ چپ‌چین: شروع از سمت چپ گره مرجع به سمت راست ★
        
        // 1. نقطه شروع: سمت چپ گره مرجع
        int startPoint = nodeLeftEdge
        
        // 2. پیدا کردن موانع در سمت راست (از چپ به راست)
        int closestObstacle = findClosestRightObstacle(nodeNotProxy, nodeLeftEdge, mapView, viewport)
        
        // 3. عرض نهایی: از سمت چپ گره مرجع تا نزدیک‌ترین مانع سمت راست
        int availableWidth = closestObstacle - startPoint - 10 // فاصله 10 پیکسل
        
        return Math.max(150, Math.min(400, availableWidth))
    }
}

def createSiblingPreviewPanel(NodeModel nodeNotProxy, boolean positionAtBottom, int referenceNodeScreenX, int referenceNodeScreenY) {
    def nodeProxy = ProxyFactory.createNode(nodeNotProxy, ScriptUtils.getCurrentContext())
    def mapView = Controller.currentController.MapViewManager.mapView
    def viewport = mapView.getParent()

    JPanel siblingsPreviewPanel = new JPanel(new BorderLayout())
    siblingsPreviewPanel.setBackground(Color.LIGHT_GRAY)
    siblingsPreviewPanel.setBorder(BorderFactory.createLineBorder(Color.BLACK, 1))

    // ذخیره اطلاعات نود برای به روزرسانی موقعیت
    def nodeData = [node: nodeNotProxy, positionAtBottom: positionAtBottom]
    siblingsPreviewPanel.putClientProperty("nodeData", nodeData)

    // ایجاد مدل برای siblings
    DefaultListModel<NodeModel> siblingsUpOrDownModel = new DefaultListModel<>()

    if (!positionAtBottom) {
        // siblings بالا
        def siblingsUP = []
        nodeProxy.parent.children.each {
            if (it.parent.children.indexOf(it) < nodeProxy.parent.children.indexOf(nodeProxy)) {
                siblingsUP.add(it.delegate)
            }
        }
        siblingsUP.each {
            if (!isNodeVisibleInViewport(it)) {
                siblingsUpOrDownModel.addElement(it)
            }
        }
    } else {
        // siblings پایین
        def siblingsDown = []
        nodeProxy.parent.children.each {
            if (it.parent.children.indexOf(it) > nodeProxy.parent.children.indexOf(nodeProxy)) {
                siblingsDown.add(it.delegate)
            }
        }
        siblingsDown.each {
            if (!isNodeVisibleInViewport(it)) {
                siblingsUpOrDownModel.addElement(it)
            }
        }
    }

    if (siblingsUpOrDownModel.size() == 0) return null

    JList<NodeModel> siblingsList = new JList<>(siblingsUpOrDownModel)
    
    // ★★★★ الگوی جدید: رندرر پیشرفته با دایره و رنگ ★★★★
    siblingsList.setCellRenderer(new DefaultListCellRenderer() {
        @Override
        public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
            JLabel label = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus)
            if (value instanceof NodeModel) {
                NodeModel currentNode = (NodeModel) value
                
                // ★ 1. دایره برای گره‌های دارای فرزند
                String prefix = ""
                if (!currentNode.isLeaf()) {
                    prefix = "○ "
                }
                
                // ★ 2. انعکاس رنگ گره
                Color backgroundColor = NodeStyleController.getController().getBackgroundColor(currentNode, StyleOption.FOR_UNSELECTED_NODE)
                Color fontColor = NodeStyleController.getController().getColor(currentNode, StyleOption.FOR_UNSELECTED_NODE)
                
                if (backgroundColor == null) {
                    backgroundColor = Color.WHITE
                }
                if (fontColor == null) {
                    fontColor = Color.BLACK
                }
                
                label.setText(prefix + (currentNode.text ?: ""))
                label.setBackground(backgroundColor)
                label.setForeground(fontColor)
                label.setOpaque(true)
                
                // ★ 3. حاشیه برای جداسازی بهتر (شبیه خطوط اتصال)
                label.setBorder(BorderFactory.createCompoundBorder(
                    BorderFactory.createMatteBorder(0, 0, 1, 0, Color.GRAY), // خط پایینی
                    BorderFactory.createEmptyBorder(2, 5, 2, 5) // حاشیه داخلی
                ))
                
                // تنظیم تراز بر اساس چیدمان انتخابی
                if (rightToLeftLayout) {
                    label.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT)
                    label.setHorizontalAlignment(SwingConstants.RIGHT)
                } else {
                    label.setComponentOrientation(ComponentOrientation.LEFT_TO_RIGHT)
                    label.setHorizontalAlignment(SwingConstants.LEFT)
                }
            }
            
            // رنگ‌های انتخاب
            if (isSelected) {
                label.setBackground(new Color(255, 255, 150)) // زرد روشن برای انتخاب
                label.setForeground(Color.BLACK)
            }
            
            return label
        }
    })

    // اضافه کردن لیسنر برای کلیک
    siblingsList.addMouseListener(new MouseAdapter() {
        @Override
        public void mouseClicked(MouseEvent e) {
            if (SwingUtilities.isLeftMouseButton(e) && e.getClickCount() == 1) {
                int index = siblingsList.locationToIndex(e.getPoint())
                if (index >= 0) {
                    NodeModel selectedNode = siblingsUpOrDownModel.getElementAt(index)
                    Controller.currentController.mapViewManager.mapView.getMapSelection().selectAsTheOnlyOneSelected(selectedNode)
                }
            }
        }
    })

    JScrollPane scrollPanelSiblingsList = new JScrollPane(siblingsList)
    
    // تنظیم موقعیت اسکرول‌بار بر اساس چیدمان
    if (rightToLeftLayout) {
        // حالت راست‌چین: اسکرول‌بار در سمت راست
        scrollPanelSiblingsList.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT)
        scrollPanelSiblingsList.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED)
    } else {
        // حالت چپ‌چین: اسکرول‌بار در سمت چپ
        scrollPanelSiblingsList.setComponentOrientation(ComponentOrientation.LEFT_TO_RIGHT)
        scrollPanelSiblingsList.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED)
    }
    
    // ★★★★ الگوریتم تنظیم ارتفاع ★★★★
    NodeView nodeView = mapView.getNodeView(nodeNotProxy)
    
    // ★★★★ الگوریتم جدید: محاسبه عرض هوشمند ★★★★
    int smartPanelWidth = calculateSmartWidthWithHierarchy(nodeNotProxy, referenceNodeScreenX, mapView, viewport)
    
    // موقعیت گره مرجع برای محاسبه نقطه شروع
    Point nodePoint = mapView.getNodeContentLocation(nodeView)
    Point nodeScreen = SwingUtilities.convertPoint(mapView, nodePoint, viewport)
    int nodeLeftEdge = nodeScreen.x
    int nodeRightEdge = nodeScreen.x + nodeView.getContentPane().width
    
    // ★★★★ محاسبه نقطه شروع بر اساس چیدمان ★★★★
    int panelStartX
    if (rightToLeftLayout) {
        // راست‌چین: شروع از سمت راست گره مرجع
        panelStartX = nodeRightEdge - smartPanelWidth
    } else {
        // چپ‌چین: شروع از سمت چپ گره مرجع  
        panelStartX = nodeLeftEdge
    }
    
    // محاسبه فضای عمودی موجود
    int verticalSpaceToViewportEdge
    if (!positionAtBottom) {
        // برای پنل بالایی: فاصله از بالای viewport تا موقعیت نود مرجع
        verticalSpaceToViewportEdge = referenceNodeScreenY
    } else {
        // برای پنل پایینی: فاصله از پایین نود مرجع تا انتهای viewport
        verticalSpaceToViewportEdge = viewport.getHeight() - (referenceNodeScreenY + nodeView.getContentPane().height)
    }
    
    // ارتفاع ثابت برای هر آیتم
    int itemHeight = 25
    
    // تعداد آیتم‌ها
    int itemsCount = siblingsUpOrDownModel.size()
    
    // محاسبه ارتفاع مورد نیاز
    int requiredHeight = itemsCount * itemHeight + 10
    
    // تعیین ارتفاع نهایی
    int finalHeight
    if (requiredHeight <= verticalSpaceToViewportEdge) {
        // نمایش تمام آیتم‌ها بدون اسکرول
        finalHeight = requiredHeight
        scrollPanelSiblingsList.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER)
        siblingsList.setVisibleRowCount(itemsCount)
    } else {
        // نمایش با اسکرول - استفاده از حداکثر فضای موجود
        finalHeight = verticalSpaceToViewportEdge - 5
        scrollPanelSiblingsList.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED)
        
        // تنظیم تعداد سطرهای قابل مشاهده بر اساس ارتفاع نهایی
        int visibleRows = (finalHeight - 10) / itemHeight
        siblingsList.setVisibleRowCount(Math.max(1, visibleRows))
    }
    
    // حداقل ارتفاع
    int minHeight = 30
    finalHeight = Math.max(finalHeight, minHeight)
    
    // ★★★★ استفاده از عرض هوشمند ★★★★
    siblingsPreviewPanel.setSize(smartPanelWidth, finalHeight)
    scrollPanelSiblingsList.setPreferredSize(new Dimension(smartPanelWidth, finalHeight))

    siblingsPreviewPanel.add(scrollPanelSiblingsList, BorderLayout.CENTER)

    // ★★★★ تنظیم موقعیت با نقطه شروع صحیح ★★★★
    if (!positionAtBottom) {
        siblingsPreviewPanel.setLocation(panelStartX, referenceNodeScreenY - finalHeight)
    } else {
        siblingsPreviewPanel.setLocation(panelStartX, referenceNodeScreenY + nodeView.getContentPane().height)
    }

    siblingsPreviewPanel.setVisible(true)
    
    // اضافه کردن به parent panel
    def parentPanel = mapView.getParent().getParent()
    parentPanel.add(siblingsPreviewPanel)
    parentPanel.setComponentZOrder(siblingsPreviewPanel, 0)

    // فورس رندر کردن
    siblingsPreviewPanel.doLayout()
    siblingsList.revalidate()
    siblingsList.repaint()
    scrollPanelSiblingsList.revalidate()
    scrollPanelSiblingsList.repaint()

    return siblingsPreviewPanel
}

def boolean isNodeVisibleInViewport(NodeModel node) {
    def mapView = Controller.currentController.MapViewManager.mapView
    def viewport = mapView.getParent()
    if (!(viewport instanceof JViewport)) return false

    NodeView nodeView = mapView.getNodeView(node)
    if (nodeView == null) return false

    def pointOnMap = mapView.getNodeContentLocation(nodeView)
    if (pointOnMap == null) return false

    Rectangle r = new Rectangle()
    r.x = pointOnMap.x
    r.y = pointOnMap.y
    r.width = nodeView.getContentPane().width
    r.height = nodeView.getContentPane().height

    def viewRect = viewport.getViewRect()
    return viewRect.intersects(r)
}

// منوی کنترل
def showControlMenu() {
    JPopupMenu menu = new JPopupMenu()
    
    // تنظیم جهت منو بر اساس چیدمان انتخابی
    if (rightToLeftLayout) {
        menu.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT)
    } else {
        menu.setComponentOrientation(ComponentOrientation.LEFT_TO_RIGHT)
    }
    
    JCheckBoxMenuItem toggleItem = new JCheckBoxMenuItem("نمایش پیش‌نمایش siblings", showSiblingsPreview)
    toggleItem.setComponentOrientation(rightToLeftLayout ? ComponentOrientation.RIGHT_TO_LEFT : ComponentOrientation.LEFT_TO_RIGHT)
    toggleItem.addActionListener({ e ->
        showSiblingsPreview = toggleItem.isSelected()
        if (!showSiblingsPreview) {
            activeSiblingPreviewPanels.each { panel ->
                panel.setVisible(false)
                panel.getParent()?.remove(panel)
            }
            activeSiblingPreviewPanels.clear()
        } else {
            refreshSiblingPreviewPanels()
        }
    })
    
    menu.add(toggleItem)
    
    // آیتم انتخاب چیدمان
    JCheckBoxMenuItem layoutItem = new JCheckBoxMenuItem("حالت راست‌چین", rightToLeftLayout)
    layoutItem.setComponentOrientation(rightToLeftLayout ? ComponentOrientation.RIGHT_TO_LEFT : ComponentOrientation.LEFT_TO_RIGHT)
    layoutItem.addActionListener({ e ->
        rightToLeftLayout = layoutItem.isSelected()
        refreshSiblingPreviewPanels() // بازسازی پنل‌ها با چیدمان جدید
    })
    menu.add(layoutItem)
    
    JMenuItem refreshItem = new JMenuItem("بروزرسانی")
    refreshItem.setComponentOrientation(rightToLeftLayout ? ComponentOrientation.RIGHT_TO_LEFT : ComponentOrientation.LEFT_TO_RIGHT)
    refreshItem.addActionListener({ e ->
        refreshSiblingPreviewPanels()
    })
    menu.add(refreshItem)
    
    return menu
}

// اجرای منو
def menu = showControlMenu()
def mapView = Controller.currentController.mapViewManager.mapView
menu.show(mapView, 100, 100)

return
